lab1-1	1.1 ucore的生成过程		将内核文件编译为中间代码			+ cc kern/init/init.c			+ cc kern/libs/readline.c			+ cc kern/libs/stdio.c			+ cc kern/debug/kdebug.c			+ cc kern/debug/kmonitor.c			+ cc kern/debug/panic.c			+ cc kern/driver/clock.c			+ cc kern/driver/console.c			+ cc kern/driver/intr.c			+ cc kern/driver/picirq.c			+ cc kern/trap/trap.c			+ cc kern/trap/trapentry.S			+ cc kern/trap/vectors.S			+ cc kern/mm/pmm.c		将库文件编译为中间代码			+ cc libs/printfmt.c			+ cc libs/string.c		将内核和库文件中的源代码编译到obj下的同名.o中，比如下面的kern/init/init.c将会被编译为obj/kern/init/init.o。			gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o		这里主要参数含义如下：			-fno-builtin	除非用__builtin_前缀，否则不视为内建函数。ucore用于避免和c内建函数重名。			-Wall			用于编译时提示警告信息。			-ggdb			生成可供gdb使用的调试信息，用于支持qemu+gdb来调试。			-m32			生成适用于32位环境的代码。当前版本ucore的设定决定了只能在32位环境中运行。			-gstabs			生成stabs格式的调试信息。			-nostdinc		不使用标准库。在ucore是在裸机中运行，并没有可以提供给ucore的标准库。相反，ucore要给ucore的用户程序提供标准库。			-fno-stack-protector  不生成用于检测缓冲区溢出的代码。这会降低效率，对于操统没有这个必要。			-I<dir>			添加搜索头文件的路径		之后是链接，链接后将生成kernel的elf文件。			+ ld bin/kernel			ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o  obj/libs/printfmt.o obj/libs/string.o		这里主要参数含义如下：			-m <emulation>		模拟为i386上的链接器。			-nostdlib			不链接标准库。操统运行在裸机上没有标准库。			-T <scriptfile>		让链接器使用指定的脚本。		编译bootloader			+ cc boot/bootasm.S			+ cc boot/bootmain.c			+ cc tools/sign.c		将其放入obj/boot的同名.o下。			gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o		对cc tools/sign.c，会直接生成其可执行文件，用于将链接好的文件变为合法的引导扇区。		值得说明的参数有：			-Os	这是一个优化选项，用于代码空间优化。因为bootloader要放入512字节的扇区中，不能太大		再是链接成bootloader的elf文件。		+ ld bin/bootblock			ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o		值得说明的参数有：			-N 		设置代码段和数据段均可读写			-e 		指定入口			-Ttext 	指定代码段开始的位置		之后运行bin/sign将其变为合法的引导扇区。		最后是生成ucore.img，dd将二进制文件写入指定文件中，第一句话生成一个有10000个块的文件，每个块默认512字节，用0填充，之后把bootloader和kernel都写进去就可以了。			dd if=/dev/zero of=bin/ucore.img count=10000			dd if=bin/bootblock of=bin/ucore.img conv=notrunc			dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc	1.2		从sign.c的代码来看，一个磁盘主引导扇区只有512字节。且第510个（倒数第二个）字节是0x55，第511个（倒数第一个）字节是0xAA。所以真正的代码只有510字节。lab1-2	2.1,2.2		通过lab1-answer中的make lab1-mon可以qemu+gdb调试。	2.3		断点后输出结果如下，		(gdb) x /10i $pc		=> 0x7c00:	cli    		   0x7c01:	cld    		   0x7c02:	xor    %ax,%ax		   0x7c04:	mov    %ax,%ds		   0x7c06:	mov    %ax,%es		   0x7c08:	mov    %ax,%ss		   0x7c0a:	in     $0x64,%al		   0x7c0c:	test   $0x2,%al		   0x7c0e:	jne    0x7c0a		   0x7c10:	mov    $0xd1,%al		与bootasm.S中有如下代码段：		start:		.code16                                             # Assemble for 16-bit mode			cli                                             # Disable interrupts			cld                                             # String operations increment			# Set up the important data segment registers (DS, ES, SS).			xorw %ax, %ax                                   # Segment number zero			movw %ax, %ds                                   # -> Data Segment			movw %ax, %es                                   # -> Extra Segment			movw %ax, %ss                                   # -> Stack Segment			# Enable A20:			#  For backwards compatibility with the earliest PCs, physical			#  address line 20 is tied low, so that addresses higher than			#  1MB wrap around to zero by default. This code undoes this.		seta20.1:			inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).			testb $0x2, %al			jnz seta20.1			movb $0xd1, %al                                 # 0xd1 -> port 0x64		两者相比，符合信息已经丢失，在二进制文件中不在需要太多的符号信息，大多数符号信息仅在链接时使用。	2.4		在0x7c02设置断点并调试		(gdb) b *0x7c02		   Breakpoint 3 at 0x7c02		(gdb) x /2i $pc		=> 0x7c02:	xor    %ax,%ax		   0x7c04:	mov    %ax,%dslab1-3	ucore中进行实模式和保护模式的切换，主要要经过以下步骤：		1.打开A20地址线		2.初始化GDT表		3.使能保护模式	打开A20地址线		A20即为地址总线上的第21位。在8086时代，为了在16位CPU上支持20位的内存，Intel使用了段寄存器移位的方式，最大支持0xffff0+0xffff。可能会产生21位的地址。在8086中，因为没有第21位地址线，会自动“回卷”。到了80286和80386的时代，多余的地址线导致了不会回卷从而产生错误。所以A20地址线可以在这些CPU中被强制置0用于回卷。		由于一些历史原因，Intel使用了8042键盘控制器的一个空闲引脚。可以通过向8042键盘控制器的port2写入0xdf来打开A20地址线。		以下是相关代码：			inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).			testb $0x2, %al			jnz seta20.2			movb $0xdf, %al                                 # 0xdf -> port 0x60			outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1	初始化GDT表		以下一段话被用于描述GDT的信息，ucore的段表非常简单，主要通过页机制处理：			.p2align 2                                          # force 4 byte alignment			gdt:				SEG_NULLASM                                     # null seg				SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel				SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel			gdtdesc:				.word 0x17                                      # sizeof(gdt) - 1				.long gdt                                       # address gdt		之后，用lgdt gdtdesc导入静态存储的段表信息，		再用下面代码使能保护模式，		    movl %cr0, %eax		    orl $CR0_PE_ON, %eax		    movl %eax, %cr0		再通过ljmp $PROT_MODE_CSEG, $protcseg这样一条长跳转语句，修改cs，跳转到保护模式下的代码。			lab1-4	bootloader为了加载操作系统主要需要解决两个问题：		1.需要有读取硬盘的能力		2.能够解析ELF文件	读取硬盘部分		读取硬盘的代码主要为readsect和readseg。readsect是一个读取一个硬盘扇区的函数，而readseg封装了readsect，可以从设备读取任意长度的内容。			static void			readsect(void *dst, uint32_t secno) {			    waitdisk();						    outb(0x1F2, 1);                         	//向端口0x1F2写入需要读的扇区数			    outb(0x1F3, secno & 0xFF);								    outb(0x1F4, (secno >> 8) & 0xFF);						    outb(0x1F5, (secno >> 16) & 0xFF);						    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);			    outb(0x1F7, 0x20);                     		//向0x1F7端口写入读指令0x20			    waitdisk();									//等待磁盘响应，读0x1F7端口			    insl(0x1F0, dst, SECTSIZE / 4);        		//连续读0x1F0端口得到该扇区数据			}	解析ELF文件		解析ELF文件的代码在bootmain中，其中用到了两个类elfhdr和proghdr也在ucore中有定义，用于指出elf文件的格式：			void bootmain(void) {			    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);			//读取ELF的头部			    if (ELFHDR->e_magic != ELF_MAGIC) {						//通过幻数判断是否是合法的ELF文件			        goto bad;			    }			    struct proghdr *ph, *eph;								//ELF头部有描述ELF文件应加载到内存什么位置的描述表，表头地址在ph中			    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);			    eph = ph + ELFHDR->e_phnum;			    for (; ph < eph; ph ++) {								//按照描述表将ELF文件中数据载入内存			        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);			    }			    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();		//根据ELF头部储存的入口信息，找到内核的入口						bad:			    outw(0x8A00, 0x8A00);			    outw(0x8A00, 0x8E00);			    while (1);			}lab1-5	代码基本原理：		通过read_ebp()获取当前栈指针，read_eip()获取当前pc。根据对栈帧结构的理解，可以输出参数，通过ebp可以在栈中跳转。	最后一行含义：		文件 行数 函数名 当前指令相对于函数开头的偏移	和示例基本一致。lab1-6	第一问：		中断向量表一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移，两者联合便是中断处理程序的入口地址。	启用中断向量表：		先使用宏SETGATE，根据vector初始化256个IDT表项，使用trap模式，内核态；然后对于软件产生的两个中断，设置门特权级为用户态，保证可以触发；最后再载入IDT表地址即可。	处理时钟中断：		在trap_dispatch中对ticks计数，模100为0时输出即可。